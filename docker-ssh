#!/usr/bin/python3
#
# docker-ssh: push and pull docker images over ssh
#
# usage:
#   docker-ssh pull [-h] [USER@]HOST[:PORT][:DOCKER_URL] IMAGE [IMAGE ...]
#   docker-ssh push [-h] [USER@]HOST[:PORT][:DOCKER_URL] IMAGE [IMAGE ...]
#
#   docker-ssh pull [-h] DOCKER_URL IMAGE [IMAGE ...]
#   docker-ssh push [-h] DOCKER_URL IMAGE [IMAGE ...]
#
# This script uses `docker save` `docker load` and a ssh session to transfer
# images from/to a docker daemon running on a remote host.
#
# If possible it calls the `docker save` command with the --exclude option so
# as not to transfer images that are already present in the destination daemon.
#

import argparse, logging, os, re, shutil, subprocess, sys, tempfile, time

PROG = "docker-ssh"

log = logging.getLogger(PROG)

class Session:

    def cmd(self, args=[]):
        raise NotImplementedError()

    def __enter__(self):
        return self

    def wait_ready(self):
        pass

    def __exit__(self, a, b, c):
        pass

class SshSession(Session):
    def __init__(self, user, host, port, url):
        self.user = user
        self.host = host
        self.port = port
        self.proc = None
        self.url  = url

    def cmd(self, args=[]):
        cmd = list(self.basecmd)
        cmd.append(self.host)
        if self.url is not None:
            cmd.extend(["/usr/bin/env", "DOCKER_HOST=" + self.url])
        assert isinstance(args, list)
        cmd.extend(args)
        return cmd

    def __enter__(self):
        assert self.proc is None
        self.tmpdir  = tempfile.TemporaryDirectory()
        self.tmpsock = os.path.join(self.tmpdir.__enter__(), "sock")

        self.basecmd = ["ssh", "-o", "ControlPath %s" % self.tmpsock, "-e", "none"]
        if self.user:
            self.basecmd.extend(["-l", self.user])
        if self.port:
            self.basecmd.extend(["-p", self.port])

        cmd = self.basecmd + ["-MN", self.host]
        log_exec(cmd)
        self.proc = subprocess.Popen(cmd)
        return self

    def wait_ready(self):
        while not os.path.exists(self.tmpsock):
            time.sleep(0.1)
            if self.proc.poll() is not None:
                die("ssh connection error")

    def __exit__(self, a, b, c):
        try:
            self.proc.terminate()
            self.proc.wait()
        finally:
            self.tmpdir.cleanup()
            self.tmpdir.__exit__(a, b, c)


class UrlSession(Session):
    def __init__(self, url):
        self.url = url

    def cmd(self, args=[]):
        return ["/usr/bin/env", "DOCKER_HOST=" + self.url] + args


def log_exec(cmd):
    log.debug("exec: %s", ((" ".join(map(repr, cmd))) if isinstance(cmd, list) else cmd))

def run(cmd, *, input="", fail_silently=False, **kw):
    log_exec(cmd)
    proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, **kw)
    out, err = proc.communicate(input)

    if proc.returncode:
        if fail_silently:
            return None
        die("subprocess returned error code %d" % proc.returncode)
    return out

def run_err(cmd, *, input="", **kw):
    log_exec(cmd)
    proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kw)
    out, err = proc.communicate(input)
    return out, proc.returncode

def die(msg):
    sys.stderr.write("%s: %s\n" % (PROG, msg))
    sys.exit(1)

def check_support_save_exclude(cmd_filter = lambda x:x):
    err, code = run_err(cmd_filter(["docker", "save", "--help"]))
    mo = re.search(b"--exclude(.*Images not to be included)?", err)
    if mo:
        return "old" if mo.group(1) else "yes"

def check_support_load_print_excludes(cmd_filter = lambda x:x):
    err, code = run_err(cmd_filter(["docker", "load", "--help"]))
    return b"--print-excludes" in err


def do_transfer(session, images, src, dst, can_exclude, can_print_excludes):
    ssh = " ".join(map(repr, session.cmd()))
    params = dict(
        images  = " ".join(map(repr, images)),
        src_ssh = ("" if src == "local" else ssh),
        dst_ssh = ("" if dst == "local" else ssh),
        pipe    = ("| pv |" if shutil.which("pv") else "|"),
    )
    del ssh
    assert params["src_ssh"] != params["dst_ssh"]

    excludes = []
    def fallback(msg, *k):
        log.warning(msg + " ==> fallback to full image export", *k)
        excludes.clear()

    if can_exclude == "yes":
        log.info("%s: 'docker save --exclude==all' supported", src)

        if can_print_excludes:
            log.info("%s: 'docker load --print-excludes' supported", dst)
            excludes = run("{src_ssh} docker save --exclude=all {images} | {dst_ssh} docker load --print-excludes"
                        .format(**params), shell=True).decode().splitlines()
        else:
            fallback("%s: 'docker load --print-excludes' not supported", dst)

    elif can_exclude == "old":
        log.info("%s: 'docker save --excludes' supported (old docker < 1.10.0)", src)

        if can_print_excludes:
            excludes.append(":")
        else:
            excludes = run("{dst_ssh} docker images -aq --no-trunc"
                            .format(**params), shell=True).decode().splitlines()

        if excludes and ":" in excludes[0]:
            fallback("%s: unable to list legacy layers (docker >= 1.10.0)", dst)
    else:
        fallback("%s: 'docker save --excludes' not supported", src)

    run("{src_ssh} docker save {exclude} {images} {pipe} {dst_ssh} docker load".format(
                exclude = (" ".join("--exclude %s" % x for x in excludes)),
                **params), shell=True)


def pull(session, images):

    can_print_excludes = check_support_load_print_excludes()
    session.wait_ready()
    can_exclude = check_support_save_exclude(session.cmd)

    do_transfer(session, images, "remote", "local", can_exclude, can_print_excludes)


def push(session, images):

    can_exclude = check_support_save_exclude()
    session.wait_ready()
    can_print_excludes = check_support_load_print_excludes(session.cmd)

    do_transfer(session, images, "local", "remote", can_exclude, can_print_excludes)


def main():
    def loglevel(value):
        v = value.upper()
        if v not in ("DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"):
            raise ValueError()
        return getattr(logging, v)

    parser = argparse.ArgumentParser(prog=PROG,
        	    description="pull and push docker images over ssh")
    parser.add_argument("--log-level", default="WARNING", type=loglevel,
            help="log level (default WARNING)")

    sub = parser.add_subparsers(dest="command", help="sub-command help")

    
    p = sub.add_parser("push", help="push images to the remote host")
    p.add_argument("remote", metavar="[USER@]HOST[:PORT][:DOCKER_URL]",
            help="paramenters to connect to the remote docker daemon")
    p.add_argument("images", metavar="IMAGE", nargs="+",
            help="docker images to be pushed")

    p = sub.add_parser("pull", help="pull images from the remote host")
    p.add_argument("remote", metavar="[USER@]HOST[:PORT][:DOCKER_URL]",
            help="paramenters to connect to the remote docker daemon")
    p.add_argument("images", metavar="IMAGE", nargs="+",
            help="docker images to be pulled")

    args = parser.parse_args()

    logging.basicConfig (level=args.log_level, format="%(levelname)-7s:%(name)s:%(message)s")

    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    if re.match(r"[a-z]+://", args.remote):
        session = UrlSession(args.remote)
    else:
        mo = re.match(r"(?:([^:@/\s]+)@)?([^:@/\s]+)(?::([^:@/\s]+))?(?::([a-z]+://.*))?$", args.remote, re.I)
        if not mo:
            die("remote host must match: [USER@]HOST[:PORT][:DOCKER_URL] or DOCKER_URL")

        args.user, args.host, args.port, args.url = mo.groups()
        session = SshSession(*mo.groups())

    with session:
        if args.command == "push":
            push(session, args.images)
        elif args.command == "pull":
            pull(session, args.images)

main()

# vim:sw=4:et:sts=4:nosta:
