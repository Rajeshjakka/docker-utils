#!/usr/bin/python3
#
# docker-ssh: push and pull docker images over ssh
#
# usage:
#   docker-ssh pull [-h] [USER@]HOST[:PORT][:DOCKER_URL] IMAGE [IMAGE ...]
#   docker-ssh push [-h] [USER@]HOST[:PORT][:DOCKER_URL] IMAGE [IMAGE ...]
#
#   docker-ssh pull [-h] DOCKER_URL IMAGE [IMAGE ...]
#   docker-ssh push [-h] DOCKER_URL IMAGE [IMAGE ...]
#
# This script uses `docker save` `docker load` and a ssh session to transfer
# images from/to a docker daemon running on a remote host.
#
# If possible it calls the `docker save` command with the --exclude option so
# as not to transfer images that are already present in the destination daemon.
#

import argparse
import contextlib
import io
import json
import logging
import os
import re
import shutil
import subprocess
import sys
import tarfile
import tempfile
import time

PROG = "docker-ssh"

log = logging.getLogger(PROG)

def die(msg):
    sys.stderr.write("%s: %s\n" % (PROG, msg))
    sys.exit(1)

def log_exec(cmd):
    log.debug("exec: %s", ((" ".join(map(repr, cmd))) if isinstance(cmd, list) else cmd))

def check_output(cmd, *k, **kw):
    log_exec(cmd)
    return subprocess.check_output(cmd, *k, **kw)

@contextlib.contextmanager
def process(cmd, *k, **kw):
    proc = None
    try:
        log_exec(cmd)
        proc = subprocess.Popen(cmd, *k, **kw)
        yield proc
        code = proc.wait()
        if code:
            raise subprocess.CalledProcessError(code, cmd)
    finally:
        if proc is not None and proc.poll() is None:
            try:
                log.debug("kill process: %r", cmd)
                proc.kill()
            except OSError:
                pass

class Pipe:
    def __init__(self, pv = False):
        if pv and shutil.which("pv"):
            self.rd, self._wr = os.pipe()
            self._rd, self.wr = os.pipe()
        else:
            self.rd, self.wr = os.pipe()

    def close(self):
        os.close(self.rd)
        os.close(self.wr)

    def __enter__(self):
        if hasattr(self, "_rd"):
            self._proc = process(["pv"], stdin=self._rd, stdout=self._wr)
            self._proc.__enter__()
            os.close(self._rd)
            os.close(self._wr)
        return self

    def __exit__(self, *k):
        if hasattr(self, "_proc"):
            self._proc.__exit__(*k)


class Session:

    def cmd(self, args=[]):
        raise NotImplementedError()

    def __enter__(self):
        return self

    def wait_ready(self):
        pass

    def __exit__(self, a, b, c):
        pass

    def can_save_exclude(self):
        return bool(re.search(
            b"--exclude.* Layers not to be included",
            check_output(self.cmd(["docker", "save", "--help"]))))

    def can_load_print_excludes(self):
        return b"--print-excludes" in check_output(
                self.cmd(["docker", "load", "--help"]))

    def save(self, images, *, stdout=None, exclude=()):

        cmd = ["docker", "save"]
        for img in exclude:
            cmd.extend(("--exclude", img))
        cmd.append("--")
        cmd.extend(images)

        return process(self.cmd(cmd), stdout=stdout)

    def load(self, *, stdin=None, stdout=None, print_excludes=False):

        cmd = ["docker", "load"]
        if print_excludes:
            cmd.append("--print-excludes")

        return process(self.cmd(cmd), stdin=stdin, stdout=stdout)

    def tag(self, img, tag):
        check_output(self.cmd(["docker", "tag", "--", img, tag]))


class LocalSession(Session):
    def cmd(self, args=[]):
        return list(args)

class SshSession(Session):
    def __init__(self, user, host, port, url):
        self.user = user
        self.host = host
        self.port = port
        self.proc = None
        self.url  = url

    def cmd(self, args=[]):
        cmd = list(self.basecmd)
        cmd.append(self.host)
        if self.url is not None:
            cmd.extend(["/usr/bin/env", "DOCKER_HOST=" + self.url])
        assert isinstance(args, list)
        cmd.extend(args)
        return cmd

    def __enter__(self):
        assert self.proc is None
        self.tmpdir  = tempfile.TemporaryDirectory()
        self.tmpsock = os.path.join(self.tmpdir.__enter__(), "sock")

        self.basecmd = ["ssh", "-o", "ControlPath %s" % self.tmpsock, "-e", "none"]
        if self.user:
            self.basecmd.extend(["-l", self.user])
        if self.port:
            self.basecmd.extend(["-p", self.port])

        cmd = self.basecmd + ["-MN", self.host]
        log_exec(cmd)
        self.proc = subprocess.Popen(cmd)
        return self

    def wait_ready(self):
        while not os.path.exists(self.tmpsock):
            time.sleep(0.1)
            if self.proc.poll() is not None:
                die("ssh connection error")

    def __exit__(self, a, b, c):
        try:
            self.proc.terminate()
            self.proc.wait()
        finally:
            self.tmpdir.cleanup()
            self.tmpdir.__exit__(a, b, c)


class UrlSession(Session):
    def __init__(self, url):
        self.url = url

    def cmd(self, args=[]):
        return ["/usr/bin/env", "DOCKER_HOST=" + self.url] + args


def prepare_translation(src, images, add_pfx, rm_pfx):

    with src.save(images, exclude=["all"], stdout=subprocess.PIPE) as proc:
        rawtar = io.BytesIO(proc.stdout.read())
    tf = tarfile.open(fileobj=rawtar)

    tag_dict = {}
    image_ids = []
    for entry in json.loads(tf.extractfile("manifest.json").read().decode()):
        img  = "sha256:" + re.match(r"([0-9a-f]{64})\.json\Z", entry["Config"]).group(1)
        image_ids.append(img)

        for old_tag in entry["RepoTags"] or ():
            if rm_pfx:
                if not old_tag.startswith(rm_pfx):
                    die("tag %r does not start with prefix %r" % (old_tag, rm_pfx))
                new_tag = add_pfx + old_tag[len(rm_pfx):]
            else:
                new_tag = add_pfx + old_tag

            tag_dict[new_tag] = img
            log.info("tag %r translated to %r", old_tag, new_tag)

    return image_ids, tag_dict


def do_transfer(src, dst, images, add_pfx, rm_pfx):

    def abort_if_pfx(role):
        if add_pfx or rm_pfx:
            if role == "send":
                die("--add-prefix/--remove-prefix requires the sending daemon to support 'docker save --excludes=all'")
            else:
                die("--add-prefix/--remove-prefix requires the receiving daemon to support 'docker load --print-excludes'")


    tag_dict = {}
    exclude = ()

    if not src.can_save_exclude():
        abort_if_pfx("send")
        log.warning("source does not support 'docker save --exclude' ==> fallback to full image export")

    elif not dst.can_load_print_excludes():
        abort_if_pfx("recv")
        log.warning("destination does not support 'docker load --print-exclude' ==> fallback to full image export")

    else:
        if add_pfx or rm_pfx:
            images, tag_dict = prepare_translation(src, images, add_pfx, rm_pfx)

        with    Pipe() as pipe,                                     \
                src.save(images, exclude=["all"], stdout=pipe.wr),  \
                dst.load(print_excludes=True,     stdin =pipe.rd, stdout=subprocess.PIPE) as proc:
            pipe.close()
            exclude = proc.communicate()[0].decode().splitlines()


    with    Pipe(pv=True) as pipe,                                     \
            src.save(images, exclude=exclude, stdout=pipe.wr),  \
            dst.load(stdin=pipe.rd):
        pipe.close()

    # apply translation
    for tag, img in tag_dict.items():
        dst.tag(img, tag)


def create_session(url):

    if re.match(r"[a-z]+://", url):
        return UrlSession(url)

    mo = re.match(r"(?:([^:@/\s]+)@)?([^:@/\s]+)(?::([^:@/\s]+))?(?::([a-z]+://.*))?$", url, re.I)
    if not mo:
        die("remote host must match: [user@]host[:port][:docker_url] or docker_url")

    user, host, port, url = mo.groups()
    return SshSession(user, host, port, url)

def main():
    def loglevel(value):
        v = value.upper()
        if v not in ("DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"):
            raise ValueError()
        return getattr(logging, v)

    parser = argparse.ArgumentParser(prog=PROG,
        	    description="pull and push docker images over ssh")
    parser.add_argument("--log-level", default="WARNING", type=loglevel,
            help="log level (default WARNING)")

    sub = parser.add_subparsers(dest="command", help="sub-command help")

    def add_push_pull_cmd(name, help):
        p = sub.add_parser(name, help=help, usage=
                "\n\t%(prog)s [USER@]HOST[:PORT][:DOCKER_URL] IMAGE [ IMAGE... ]"
                "\n\t%(prog)s DOCKER_URL                      IMAGE [ IMAGE... ]")
        p.add_argument("--add-prefix", default="", metavar="PREFIX",
                help="prefix to be prepended to the image name (in the destination daemon)")
        p.add_argument("--remove-prefix", default="", metavar="PREFIX",
                help="prefix to be removed from the image name (in the destination daemon)")
        p.add_argument("remote", metavar="[USER@]HOST[:PORT][:DOCKER_URL]",
                help="paramenters to connect to the remote docker daemon")
        p.add_argument("images", metavar="IMAGE", nargs="+",
                help="docker images to be transferred")
    
    add_push_pull_cmd("push", help="push images to the remote host")
    add_push_pull_cmd("pull", help="pull images from the remote host")

    args = parser.parse_args()

    logging.basicConfig (level=args.log_level, format="%(levelname)-7s:%(name)s:%(message)s")

    if not args.command:
        parser.print_help()
        sys.exit(1)

    local  = LocalSession()
    remote = create_session(args.remote)

    if args.command == "pull":
        src, dst = remote, local
    elif args.command == "push":
        src, dst = local, remote
    else:
        raise NotImplementedError(args.command)
 
    with src, dst:
        src.wait_ready()
        dst.wait_ready()

        do_transfer(src, dst, args.images, args.add_prefix, args.remove_prefix)

main()

# vim:sw=4:et:sts=4:nosta:
